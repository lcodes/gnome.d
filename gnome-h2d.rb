#!/usr/bin/ruby
# -*- mode: Ruby; tab-width: 2; fill-column: 100; -*-


# gnome-h2d.rb - Converts GNOME's C headers to The D Programming Language.
#
# Version:   0.1
# Author:    Jeremie Pelletier <jeremie.@gmail.com>
# Homepage:  <http://github.com/ddude/gnome.d>
# History:   2012-06-27 - Initial commit, tested against glib-2.33.2.
# Copyright: (c) Jeremie Pelletier 2012
# License:   Boost License 1.0.


require 'fileutils'
require 'optparse'

# Comment inserted at the top of every file generated by this script.
genHeader = "// Generated by gnome-h2d.rb <http://github.com/ddude/gnome.d>.\n\n"

# Get the paths to the source directories from the command line.
paths = {
  :glib => nil,
  :gtk  => nil,
  :dst  => nil
}

opts = OptionParser.new do |opts|
  opts.banner = "Usage: gnome-h2d.rb [options]"

  opts.on('--glib [PATH]', 'Path to the GLIB sources') do |path|
    paths[:glib] = path
  end

  opts.on('--gtk [PATH]', 'Path to the GTK sources') do |path|
    paths[:gtk] = path
  end

  opts.on('--dst PATH', 'Destination path for generated D modules.') do |path|
    paths[:dst] = path
  end

  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end
end

opts.parse! ARGV

if paths[:dst] == nil
  $stderr << "No destination path given.\n"
  exit
end

# Used to lookup what library a given API is part of.
apiPathLookup = {
  :glib         => :glib,
  :gobject      => :glib,
  :gmodule      => :glib,
  :gthread      => :glib,
  :gio          => :glib,
  :gdk          => :gtk,
  :gtk          => :gtk
}

# Explicit opaque structures. By default only '<moduleName>' and '<moduleName>Private' are enabled.
opaqueStructs = {
  :glib => {
    'array'     => ['bytes'],
    'convert'   => ['iconv'],
    'dataset'   => ['data'],
    'hash'      => ['hashtable'],
    'main'      => ['maincontext', 'sourceprivate', 'mainloop'],
    'markup'    => ['markupparsecontext'],
    'option'    => ['optioncontext', 'optiongroup'],
    'regex'     => ['matchinfo', 'regex'],
    'pattern'   => ['patternspec'],
    'sequence'  => ['sequence', 'sequenceiter'],
    'testutils' => ['testcase', 'testsuite'],
    'utils'     => ['voidfunc']
  },
  :gobject => {
    'type'      => ['typecvalue', 'typeplugin'],
    'param'     => ['paramspecpool']
  },
  :gmodule => {
    'gmodule'   => ['module']
  },
  :gio => {
    'appinfo'   => ['applaunchcontextprivate'],
    'desktopappinfo' => ['desktopappinfo', 'desktopappinfolookup'],
    'menumodel' => ['menumodelprivate', 'menuattributeiterprivate', 'menulinkiterprivate'],
    'menu'      => ['menu', 'menuitem'],
    'module_'   => ['iomodulescope'],
    'settingsschema' => ['settingsschema', 'settingsschemasource'],
    'stream'    => ['iostreamprivate'],
    'types'     => ['action', 'asyncresult', 'simpleasyncresult', 'ioschedulerjob',
                    'settingsbackend', 'dbusobjectmanagerclient', 'actiongroup', 'dbusconnection',
                    'actionmap', 'dbusobjectskeleton', 'simpleaction', 'appinfo', 'icon', 'file',
                    'fileicon', 'permission', 'zlibcompressor', 'zlibdecompressor',
                    'applicationcommandline', 'application', 'remoteactiongroup', 'initable',
                    'asyncinitable', 'converter', 'charsetconverter', 'credentials',
                    'dbusauthobserver', 'dbusinterface', 'dbusmessage', 'dbusmethodinvocation',
                    'dbusserver', 'filedescriptorbased', 'drive', 'mountoperation', 'fileinfo',
                    'mount', 'fileattributeinfolist', 'fileinputstream', 'fileoutputstream',
                    'fileattributematcher', 'inetaddressmask', 'filenamecompleter', 'inetaddress',
                    'ioextensionpoint', 'ioextension', 'loadableicon', 'volume',
                    'socketconnectable', 'networkmonitor', 'pollableinputstream',
                    'pollableoutputstream', 'proxy', 'proxyaddress', 'proxyresolver', 'resource',
                    'seekable', 'socketaddressenumerator', 'srvtarget', 'testdbus', 'themedicon',
                    'tlsdatabase', 'tlscertificate', 'tlsinteraction', 'tlsclientconnection',
                    'tlspassword', 'dbusobject', 'dbusinterfacevtable', 'dbusinterfaceskeleton',
                    'dbusobjectmanager', 'dbusobjectproxy', 'dbusproxy', 'dbusactiongroup',
                    'menuitem', 'iomodule', 'iomodulescope', 'dbusmethodinfo', 'icon'],
    'unixmounts' => ['unixmountentry', 'unixmountpoint', 'unixmountmonitor'],
    'unixvolumemonitor' => ['unixmount', 'unixvolume', 'unixvolumemonitor'],
    'win32volumemonitor' => ['win32mount', 'win32volume', 'win32volumemonitor']
  }
}

# Files that only need to declare the private opaque structure.
privateOpaqueStructOnly = {
  :gio => ['dataoutputstream', 'dbusauth', 'dbusauthmechanism', 'dbusauthmechanismanon',
           'dbusauthmechanismexternal', 'dbusauthmechanismsha1', 'delayedsettingsbackend',
           'emblemedicon', 'localdirectorymonitor', 'localfilemonitor', 'localfileiostream',
           'localfileinputstream', 'localfileoutputstream', 'nativevolumemonitor',
           'networkmonitorbase', 'networkmonitornetlink', 'socketinputstream',
           'socketoutputstream', 'socks4aproxy', 'unixconnection', 'socketcontrolmessage',
           'unixfdmessage', 'socketconnection', 'unixfdlist', 'unixinputstream',
           'unixoutputstream', 'unixsocketaddress', 'win32inputstream', 'win32outputstream']
}

# Files that don't need opaque structures at all.
noOpaqueStructs = {
  :glib => ['error', 'date', 'list', 'hook', 'iochannel', 'slist', 'string',
            'node', 'queue', 'scanner', 'threadpool', 'trashstack'],
  :gobject => ['atomicarray', 'object', 'closure', 'typemodule', 'valuearray']
}

# Module imports to add to specific files.
importsByModule = {
  'core.stdc.stdarg' => {
    :glib    => ['string', 'variant'],
    :gobject => ['closure', 'marshal', 'object', 'signal']
  },
  'gobject.gobject' => {
    :gio     => ['types', 'enums', 'enumtypes']
  },
  'gio.types' => {
    :gio     => ['registrysettingsbackend', 'settingsmapping', 'settingsschema']
  }
}

# Files needing specific module imports.
importsByName = {
  :glib    => {
    'intl' => ['glib.glib'],
    'spawn' => ['glib.main']
  },
  :gobject => {
    'marshal' => ['gobject.types', 'gobject.closure'],
    'type' => ['gobject.types', 'gobject.value'],
    'types' => ['gobject.type']
  },
  :gio => {
    'emblem' => ['gio.icon'],
    'file' => ['gio.fileenumerator', 'gio.filemonitor'],
    'localvfs' => ['gio.vfs'],
    'types' => ['gio.cancellable', 'gio.dbusintrospection', 'gio.socket', 'gio.socketaddress',
                'gio.socketcontrolmessage', 'gio.stream', 'gio.inputstream', 'gio.unixfdlist',
                'gio.fileiostream', 'gio.socketconnection'],
    'unixmount' => ['gio.unixvolumemonitor'],
    'unixvolumemonitor' => ['gio.unixmount'],
    'win32mount' => ['gio.win32volumemonitor']
  }
}

# Pattern to match filenames to skip during the conversion.
ignorePattern = /macros|priv(?:ate)?|internal|scripttable|unicomp|mirroringtable|generated/

# Array of syntax/semantic test files.
testFiles = []

testDir = "#{paths[:dst]}/../tests"
FileUtils.mkdir_p testDir

# Skip GTK for now, to be added in 0.2.
debugSkipLibs = [:gdk, :gtk]

# Convert each API.
[:glib, :gobject, :gmodule, :gthread, :gio, :gdk, :gtk].each do |api|
  lib = apiPathLookup[api]

  next if lib == nil or debugSkipLibs.include? api

  src = "#{paths[lib]}/#{api}"
  dst = "#{paths[:dst]}/#{api}"

  $stdout << 'Processing ' << api << ' from ' << lib << "\n"
  $stdout << '  src = ' << src << "\n"
  $stdout << '  dst = ' << dst << "\n"
  
  # Determine the file prefix pattern.
  prefix = ''
  if api == :glib or api == :gobject then prefix = 'g(?:lib)?'
  elsif api == :gio then prefix = 'g(?:io)?'
  else prefix = api
  end

  # Create the destination directory.
  FileUtils.mkdir_p dst

  # Keep a list of all the converted modules for this API.
  allNames = []

  # Convert every file found for this API.
  Dir.foreach src do |f|
    if (m = /^#{prefix}(.*)\.h$/.match f) and not (ignorePattern.match f)
      # Determine the D module name.
      name = m[1].gsub(/\-/, '').sub /^_/, ''
      name = api.to_s if name == ''
      name = 'gio' if name == 'io'
      name = 'gobject' if name == 'object'
      name = 'module_' if name == 'module'
      name = 'version_' if name == 'version'
      name = 'debug_' if name == 'debug'
      name = 'switch_' if name == 'switch'
      fileName = "#{name}.d"

      allNames << name
      $stdout << 'Converting ' << f << ' to ' << fileName << "\n"
      
      # Read the source file.
      sourceFile = File.open "#{src}/#{f}", 'r'
      source = sourceFile.read
      sourceFile.close
      
      # Perform glib-specific transforms first.
      if api == :glib
        source.gsub! /#include "g(.+?).h"/, 'import glib.\\1;'
        source.gsub! /(#include <glib\/.+?macros\.h>)/, '//\\1'
        source.gsub! /GLIB_VAR/, 'extern'
        if name == 'array'
        elsif name == 'base64'
          source.gsub! /(\W(?:in|out))(?=[\,\)])/, '\\1_'
        elsif name == 'bsearcharray'
          source.gsub! /(static inline)/, '/*\\1*/'
          source.sub! /(\/\* --- implementation .+)/m, "/+\n\\1\n+/"
        elsif name == 'date'
          source.gsub! /(?:struct) (tm)/, '\\1'
        elsif name == 'glib'
          source.sub! /glib\/gversion/, 'glib/gversion_'
          source.gsub! /(#include <glib\/deprecated\/(?:.+?).h>)/, '//\\1'
        elsif name == 'iochannel'
          source.gsub! /(G_IO_[A-Z]+)\s+(GLIB_SYSDEF_.+),?/, '\\1 = 0, //\\2'
        elsif name == 'main'
          source.gsub! /\(\*ref\)/, '(*ref_)'
          source.gsub! /function,/, 'function_,'
        elsif name == 'printf'
          source.gsub! /gchar const \*/, 'const(gchar)*'
        elsif name == 'sequence'
          source.gsub! /typedef struct _GSequenceNode  GSequenceIter/, 'typedef struct _GSequenceIter GSequenceIter'
        elsif name == 'stdio'
          source.sub! /struct utimbuf \*/, 'utimbuf* '
          source.sub! /sys\/stat.h>/, "sys/stat.h>\nimport core.stdc.stdio;\n\nalias stat_t GStatBuf;"
        elsif name == 'types'
          source.sub! /typedef long/, 'alias int'
          source.sub! /unsigned char/, 'ubyte'
          source.sub! /unsigned short/, 'ushort'
          source.gsub! /unsigned (int|long)/, 'uint'
        elsif name == 'testutils'
          source.gsub! /long double/, 'real'
        elsif name == 'utils'
          source.gsub! /gchar const \*/, 'const(gchar)*'
          source.sub! /void\s+g_atexit.+?;/, '//\\1'
          source.sub! /(\/\* inline function implementations.+?__G_UTILS_C__ \*\/)/m, '/+ \\1 +/'
        elsif name == 'variant'
          source.gsub! /GVariant \* const/, 'const(GVariant)*'
        elsif name == 'win32'
          source.gsub! /package,/, 'package_,'
        end
      end

      # Remove the include guard.
      source.sub! /#ifndef __(.+?)_H__\n#define __\1_H__/, ''
      source.sub! /#endif\s+\/\*\s*!?__.+?_H__?\s*\*\//, ''

      # Map C includes to their corresponding D imports.
      source.gsub! /#include\s+<(?:glib\/)?glib\.h>/, 'public import glib.glib;'
      source.gsub! /#include\s+<g(lib|object|io)\/g(?:(?:\1|lib)\-?)?(.+?)\.h>/, 'public import g\\1.\\2;'
      source.gsub! /(#include\s+<(.+?config)\.h>)/, '//\\1'
      source.gsub! /#include\s+<(fcntl|signal|unistd)\.h>/, 'import core.sys.posix.\\1;'
      source.gsub! /#include\s+<sys\/(stat|wait)\.h>/, 'import core.sys.posix.sys.\\1;'
      source.gsub! /#include\s+<(errno|time|std(?:arg|def|lib|io)|string)\.h>/, 'import core.stdc.\\1;'
      source.gsub! /#include\s+<(libintl)\.h>/, '//import etc.c.libintl;'

      # Ignore macro definitions, for now.
      source.gsub! /(#(?:define|undef))/m, '//\\1'
      source.gsub! /\\\n/, "\n//"

      # Remove the preprocessor's conditional compilation, for now.
      source.gsub! /(#if.+?(?:\n?#endif)+)/m, "/+\n\\1\n+/"
      source.gsub! /(#(?:else|endif))/, '//\\1'

      # Keep the C calling convention.
      source.sub! /G_BEGIN_DECLS/, 'extern(C):'
      source.sub! /G_END_DECLS/, ''
      
      # Replace 'typedef struct' with 'struct'.
      source.gsub! /typedef\s+(struct|union|enum)/, '\\1'
      # Remove 'struct _Abc Abc;', declare 'struct Abc' directly.
      source.gsub! /((?:struct|union)\s+_?(\S+)\s+\*?\2;)/, '//\\1'
      source.gsub! /(struct|union)\s+_(\S+)\s*\{/m, '\\1 \\2 {'
      # Change 'struct /* opt comment */ { ... } Abc' into 'struct Abc { ... }'.
      source.gsub! /(struct|union|enum)\s+?(?:\/\*.+?\*\/\s+)?\{(.*?)\} ([a-zA-Z0-9_\[\]]+);/m, '\\1 \\3 {\\2}'

      # Replace C keywords with D equivalents.
      source.gsub! /volatile/, 'shared'
      source.gsub! /static const/, 'immutable'

      # Remove bitfields from structs, for now.
      source.gsub! /((?:shared\s+)?\S+\s+\S+\s+:\s+\d+;)/, '/*\\1*/'

      # Remove function annotations.
      source.gsub! /\s*G_GNUC_(?:CONST|PURE)/, ' pure'
      source.gsub! /(G_GNUC_(?:INTERNAL|NORETURN|WARN_UNUSED_RESULT|NULL_TERMINATED|MALLOC|(?:PRINTF|FORMAT|ALLOC_SIZE)[^;]+))/m,
                   '/+ \\1 +/'
      source.gsub! /(G_INLINE_FUNC)/, '/+ \\1 +/'
      source.gsub! /(GLIB_AVAILABLE_IN_.+)/, '/+ \\1 +/'
      source.gsub! /(GLIB_DEPRECATED(?:_IN_\d+_\d+)?(?:_FOR\([^\)]+\))?)/, '/+ \\1 +/'

      # D's typedefs are deprecated type constructors, use aliases instead.
      source.gsub! /^typedef/, 'alias'
      # Update function pointers to use D's syntax.
      source.gsub! /\( ?\*\s*([a-zA-Z0-9_]+) ?\)\s*\((.+?)\);/m, 'function(\\2) \\1;'

      # Don't define functions with no arguments as `(void)'.
      source.gsub! /\(void\)/, '()'

      # Update C's non-transitive const pointers to use D's transitive const qualifier.
      source.gsub! /const\s+(.+?)\s*\*\s*const\s*(\*)?/, 'const(\\1*)\\2'
      source.gsub! /([^_])const\s+(.+?)(\s*)\*/, '\\1const(\\2)*\\3'

      #source.gsub! /const\(gchar\)\*(\s+)version/, 'const(gchar)*\\1version_'
      #source.gsub! /G(d|t)kAlign(\s+)align/, 'G\\1kAlign\\2align_'

      # File specific opaque structures.
      unless noOpaqueStructs.has_key? api and noOpaqueStructs[api].include? name
        structs = [ name ]
        priv = '(?:Private)'
        priv += '?' unless privateOpaqueStructOnly.has_key? api and privateOpaqueStructOnly[api].include? name

        if opaqueStructs.has_key? api and opaqueStructs[api].has_key? name
          structs = opaqueStructs[api][name]
        end

        structs.each do |s|
            source.gsub! /\/\/(struct|union)\s+_?(g#{s}#{priv})\s+\*?\2\s*;/i, "\\1 _\\2;\nalias _\\2* \\2;"
        end
      end

      # API imports.
      source.sub! /import g(lib|object)\.object;/, 'import g\\1.gobject;'

      # GObject specific transforms.
      if api == :gobject
        source.gsub! /GOBJECT_VAR/, 'extern'
        if name == 'gobject'
          source.gsub! /(struct _GObject(?:Class)?.+?;)/, '//\\1'
          source.sub! /struct priv \{.+?\} GWeakRef;/m, 'struct GWeakRef { gpointer p; }'
        elsif name == 'param'
          source.sub! /struct _GParameter \//, 'struct GParameter /'
        elsif name == 'typemodule'
          source.gsub! /\*module(,|\))/, '*module_\\1'
        elsif name == 'value'
          source.sub! /union data\[2\] \{(.+?)\}/m, 'union data_t {\\1} data_t data;'
        elsif name == 'valuecollector'
          source.sub! /#include <glib\-object\.h>/, 'public import glib.gobject;'
        end
      # GModule specific transforms.
      elsif api == :gmodule
        if name == 'gmodule'
          source.gsub! /\*module(\)|,)/, '*module_\\1'
        end
      # GIO specific transforms.
      elsif api == :gio
        source.sub! /import gio\.io;/, 'import gio.gio;'
        source.gsub! /#include\s+"g(?:io)?(.+?)\.h"/, 'public import gio.\\1;'
        source.sub! /#include <glib\-object\.h>/, '//\\1'
        if name == 'dbusmessage'
          source.sub! /body\);/, 'body_);'
        elsif name == 'enums'
          source.sub! /enum _([a-zA-Z]+)(.+?) \1;/m, 'enum \\1\\2'
          source.gsub! /(G_SOCKET_(?:FAMILY|MSG)_(?:UNIX|IPV(?:4|6)|OOB|PEEK|DONTROUTE).+)/, '//\\1'
        elsif name == 'gio'
          source.sub! /module;/, 'module_;'
        elsif name == 'icon'
          source.sub! /version,/, 'version_,'
        elsif name == 'localfileinputstream'
          source.sub! /in,/, 'in_,'
        elsif name == 'localfileoutputstream'
          source.gsub! /out,/, 'out_,'
        elsif name == 'localfileinfo'
          source.sub! /(gio\.file;)/, "\\1\nimport core.stdc.stdio;\n\nalias stat_t GLocalFileStat;"
        elsif name == 'module_'
          source.sub! /#include <gmodule\.h>/, 'public import gmodule.gmodule;'
          source.gsub! /(module|scope)(\)|,)/, '\\1_\\2'
        elsif name == 'settingsbackend'
          source.sub! /gchar const\(\* const\)\*/, 'const(gchar*)*'
        end
        source.gsub! /#include\s+<g(.+?)\.h>/, 'public import gio.\\1;'
      end

      # Write the target D module.
      target = File.open "#{dst}/#{fileName}", 'w'
      target.write genHeader
      target.write "module #{api}.#{name};\n\n"

      # Glib specific file declarations.
      if api == :glib
        if name == 'main'
          target.write "alias int GPid;\n\n"
        elsif name == 'types'
          target.write "alias byte gint8;\n"
          target.write "alias ubyte guint8;\n"
          target.write "alias short gint16;\n"
          target.write "alias ushort guint16;\n"
          target.write "alias int gint32;\n"
          target.write "alias uint guint32;\n"
          target.write "alias long gint64;\n"
          target.write "alias ulong guint64;\n"
          target.write "alias size_t gsize;\n"
          target.write "alias sizediff_t gssize;\n\n"
        elsif name == 'utils'
          target.write "alias long goffset;\n\n"
        end
      # GObject specific file declarations.
      elsif api == :gobject
        if name == 'types'
          target.write "alias size_t GType;\n\n"
        end
      end

      # Add import declarations.
      importsByModule.each do |import, apis|
        if apis.has_key? api and apis[api].include? name
          target.write "public import #{import};\n"
        end
      end
      if importsByName.has_key? api and importsByName[api].has_key? name
        importsByName[api][name].each do |import|
          target.write "public import #{import};\n"
        end
      end

      target.write source
      target.close
    end
  end

  # Generate the <api>.d import module.
  $stdout << "Generating #{api}.d\n"
  
  d = File.open "#{dst}/d.d", 'w'
  d.write genHeader
  d.write "module #{api}.d;\n\n"
  d.write "public {\n"
  allNames.each { |x| d.write "    import #{api}.#{x};\n" }
  d.write "}\n"
  d.close
  
  # Generate a test module to validate the syntax and semantics of converted modules.
  $stdout << "Generating #{api}test.d\n"
  
  testFileName = "#{testDir}/#{api}test.d"
  
  test = File.open testFileName, 'w'
  test.write "#!/usr/bin/rdmd -unittest -debug -w -wi -I#{dst}/..\n\n"
  test.write genHeader
  test.write "module #{api}test;\n\n"
  test.write "import #{api}.d;\n\n"
  test.write "void main() {}\n"
  test.close
  
  testFiles << testFileName
end

# Run the generated tests.
testFiles.each do |testFileName|
  $stdout << "Running #{testFileName}.\n"
  
  %x[chmod +x #{testFileName}]
  exit unless $?.to_i == 0

  %x[#{testFileName}]
  exit unless $?.to_i == 0
end

$stdout << "Done\n"


# Boost Software License - Version 1.0 - August 17th, 2003 

# Permission is hereby granted, free of charge, to any person or organization obtaining a copy of
# the software and accompanying documentation covered by this license (the "Software") to use,
# reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative
# works of the Software, and to permit third-parties to whom the Software is furnished to do so, all
# subject to the following:

# The copyright notices in the Software and this entire statement, including the above license
# grant, this restriction and the following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all derivative works of the Software, unless such copies or
# derivative works are solely in the form of machine-executable object code generated by a source
# language processor.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
# NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
# NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE
# LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
