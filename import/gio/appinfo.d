// Generated by gnome-h2d.rb <http://github.com/ddude/gnome.d>.

module gio.appinfo;

/* GIO - GLib Input, Output and Streaming Library
 *
 * Copyright (C) 2006-2007 Red Hat, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307, USA.
 *
 * Author: Alexander Larsson <alexl@redhat.com>
 */

/+
#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
#error "Only <gio/gio.h> can be included directly."
//#endif
+/



public import gio.types;

extern(C):

//#define G_TYPE_APP_INFO            (g_app_info_get_type ())
//#define G_APP_INFO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_APP_INFO, GAppInfo))
//#define G_IS_APP_INFO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_APP_INFO))
//#define G_APP_INFO_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_APP_INFO, GAppInfoIface))

//#define G_TYPE_APP_LAUNCH_CONTEXT         (g_app_launch_context_get_type ())
//#define G_APP_LAUNCH_CONTEXT(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContext))
//#define G_APP_LAUNCH_CONTEXT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass))
//#define G_IS_APP_LAUNCH_CONTEXT(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_APP_LAUNCH_CONTEXT))
//#define G_IS_APP_LAUNCH_CONTEXT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_APP_LAUNCH_CONTEXT))
//#define G_APP_LAUNCH_CONTEXT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass))

//struct _GAppLaunchContextClass   GAppLaunchContextClass;
struct _GAppLaunchContextPrivate;
alias _GAppLaunchContextPrivate* GAppLaunchContextPrivate;

/**
 * GAppInfo:
 *
 * Information about an installed application and methods to launch
 * it (with file arguments).
 */

/**
 * GAppInfoIface:
 * @g_iface: The parent interface.
 * @dup: Copies a #GAppInfo.
 * @equal: Checks two #GAppInfo<!-- -->s for equality.
 * @get_id: Gets a string identifier for a #GAppInfo.
 * @get_name: Gets the name of the application for a #GAppInfo.
 * @get_description: Gets a short description for the application described by the #GAppInfo.
 * @get_executable: Gets the executable name for the #GAppInfo.
 * @get_icon: Gets the #GIcon for the #GAppInfo.
 * @launch: Launches an application specified by the #GAppInfo.
 * @supports_uris: Indicates whether the application specified supports launching URIs.
 * @supports_files: Indicates whether the application specified accepts filename arguments.
 * @launch_uris: Launches an application with a list of URIs.
 * @should_show: Returns whether an application should be shown (e.g. when getting a list of installed applications).
 * <ulink url="http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt">
 * <citetitle>FreeDesktop.Org Startup Notification Specification</citetitle></ulink>.
 * @set_as_default_for_type: Sets an application as default for a given content type.
 * @set_as_default_for_extension: Sets an application as default for a given file extension.
 * @add_supports_type: Adds to the #GAppInfo information about supported file types.
 * @can_remove_supports_type: Checks for support for removing supported file types from a #GAppInfo.
 * @remove_supports_type: Removes a supported application type from a #GAppInfo.
 * @can_delete: Checks if a #GAppInfo can be deleted. Since 2.20
 * @do_delete: Deletes a #GAppInfo. Since 2.20
 * @get_commandline: Gets the commandline for the #GAppInfo. Since 2.20
 * @get_display_name: Gets the display name for the #GAppInfo. Since 2.24
 * @set_as_last_used_for_type: Sets the application as the last used. See g_app_info_set_as_last_used_for_type().
 *
 * Application Information interface, for operating system portability.
 */
//struct _GAppInfoIface    GAppInfoIface;

struct GAppInfoIface {
  GTypeInterface g_iface;

  /* Virtual Table */

  GAppInfo *   function(GAppInfo           *appinfo) dup;
  gboolean     function(GAppInfo           *appinfo1,
                                                 GAppInfo           *appinfo2) equal;
  const(char)*  function(GAppInfo           *appinfo) get_id;
  const(char)*  function(GAppInfo           *appinfo) get_name;
  const(char)*  function(GAppInfo           *appinfo) get_description;
  const(char)*  function(GAppInfo           *appinfo) get_executable;
  GIcon *      function(GAppInfo           *appinfo) get_icon;
  gboolean     function(GAppInfo           *appinfo,
                                                 GList              *files,
                                                 GAppLaunchContext  *launch_context,
                                                 GError            **error) launch;
  gboolean     function(GAppInfo           *appinfo) supports_uris;
  gboolean     function(GAppInfo           *appinfo) supports_files;
  gboolean     function(GAppInfo           *appinfo,
                                                 GList              *uris,
                                                 GAppLaunchContext  *launch_context,
                                                 GError            **error) launch_uris;
  gboolean     function(GAppInfo           *appinfo) should_show;

  /* For changing associations */
  gboolean     function(GAppInfo           *appinfo,
                                                 const(char)*         content_type,
                                                 GError            **error) set_as_default_for_type;
  gboolean     function(GAppInfo           *appinfo,
                                                 const(char)*         extension,
                                                 GError            **error) set_as_default_for_extension;
  gboolean     function(GAppInfo           *appinfo,
                                                 const(char)*         content_type,
                                                 GError            **error) add_supports_type;
  gboolean     function(GAppInfo           *appinfo) can_remove_supports_type;
  gboolean     function(GAppInfo           *appinfo,
                                                 const(char)*         content_type,
                                                 GError            **error) remove_supports_type;
  gboolean     function(GAppInfo           *appinfo) can_delete;
  gboolean     function(GAppInfo           *appinfo) do_delete;
  const(char)*  function(GAppInfo           *appinfo) get_commandline;
  const(char)*  function(GAppInfo           *appinfo) get_display_name;
  gboolean     function(GAppInfo           *appinfo,
                                                 const(char)*         content_type,
                                                 GError            **error) set_as_last_used_for_type;
  const(char)* * function(GAppInfo           *appinfo) get_supported_types;
};

GType       g_app_info_get_type                     () pure;
GAppInfo *  g_app_info_create_from_commandline      (const(char)*           commandline,
                                                     const(char)*           application_name,
                                                     GAppInfoCreateFlags   flags,
                                                     GError              **error);
GAppInfo *  g_app_info_dup                          (GAppInfo             *appinfo);
gboolean    g_app_info_equal                        (GAppInfo             *appinfo1,
                                                     GAppInfo             *appinfo2);
const(char)* g_app_info_get_id                       (GAppInfo             *appinfo);
const(char)* g_app_info_get_name                     (GAppInfo             *appinfo);
const(char)* g_app_info_get_display_name             (GAppInfo             *appinfo);
const(char)* g_app_info_get_description              (GAppInfo             *appinfo);
const(char)* g_app_info_get_executable               (GAppInfo             *appinfo);
const(char)* g_app_info_get_commandline              (GAppInfo             *appinfo);
GIcon *     g_app_info_get_icon                     (GAppInfo             *appinfo);
gboolean    g_app_info_launch                       (GAppInfo             *appinfo,
                                                     GList                *files,
                                                     GAppLaunchContext    *launch_context,
                                                     GError              **error);
gboolean    g_app_info_supports_uris                (GAppInfo             *appinfo);
gboolean    g_app_info_supports_files               (GAppInfo             *appinfo);
gboolean    g_app_info_launch_uris                  (GAppInfo             *appinfo,
                                                     GList                *uris,
                                                     GAppLaunchContext    *launch_context,
                                                     GError              **error);
gboolean    g_app_info_should_show                  (GAppInfo             *appinfo);

gboolean    g_app_info_set_as_default_for_type      (GAppInfo             *appinfo,
                                                     const(char)*           content_type,
                                                     GError              **error);
gboolean    g_app_info_set_as_default_for_extension (GAppInfo             *appinfo,
                                                     const(char)*           extension,
                                                     GError              **error);
gboolean    g_app_info_add_supports_type            (GAppInfo             *appinfo,
                                                     const(char)*           content_type,
                                                     GError              **error);
gboolean    g_app_info_can_remove_supports_type     (GAppInfo             *appinfo);
gboolean    g_app_info_remove_supports_type         (GAppInfo             *appinfo,
                                                     const(char)*           content_type,
                                                     GError              **error);
/+ GLIB_AVAILABLE_IN_2_34 +/
const(char)* *g_app_info_get_supported_types         (GAppInfo             *appinfo);

gboolean    g_app_info_can_delete                   (GAppInfo   *appinfo);
gboolean    g_app_info_delete                       (GAppInfo   *appinfo);

gboolean    g_app_info_set_as_last_used_for_type    (GAppInfo             *appinfo,
                                                     const(char)*           content_type,
                                                     GError              **error);

GList *   g_app_info_get_all                     ();
GList *   g_app_info_get_all_for_type            (const(char)*  content_type);
GList *   g_app_info_get_recommended_for_type    (const(gchar)* content_type);
GList *   g_app_info_get_fallback_for_type       (const(gchar)* content_type);

void      g_app_info_reset_type_associations     (const(char)*  content_type);
GAppInfo *g_app_info_get_default_for_type        (const(char)*  content_type,
                                                  gboolean     must_support_uris);
GAppInfo *g_app_info_get_default_for_uri_scheme  (const(char)*  uri_scheme);

gboolean  g_app_info_launch_default_for_uri      (const(char)*              uri,
                                                  GAppLaunchContext       *launch_context,
                                                  GError                 **error);

/**
 * GAppLaunchContext:
 *
 * Integrating the launch with the launching application. This is used to
 * handle for instance startup notification and launching the new application
 * on the same screen as the launching window.
 */
struct GAppLaunchContext {
  GObject parent_instance;

  /*< private >*/
  GAppLaunchContextPrivate *priv;
};

struct GAppLaunchContextClass {
  GObjectClass parent_class;

  char * function(GAppLaunchContext *context,
                                    GAppInfo          *info,
                                    GList             *files) get_display;
  char * function(GAppLaunchContext *context,
                                    GAppInfo          *info,
                                    GList             *files) get_startup_notify_id;
  void   function(GAppLaunchContext *context,
                                    const(char)*        startup_notify_id) launch_failed;

  /* Padding for future expansion */
  void function() _g_reserved1;
  void function() _g_reserved2;
  void function() _g_reserved3;
  void function() _g_reserved4;
  void function() _g_reserved5;
};

GType              g_app_launch_context_get_type              () pure;
GAppLaunchContext *g_app_launch_context_new                   ();

/+ GLIB_AVAILABLE_IN_2_32 +/
void               g_app_launch_context_setenv                (GAppLaunchContext *context,
                                                               const(char)*        variable,
                                                               const(char)*        value);
/+ GLIB_AVAILABLE_IN_2_32 +/
void               g_app_launch_context_unsetenv              (GAppLaunchContext *context,
                                                               const(char)*        variable);
/+ GLIB_AVAILABLE_IN_2_32 +/
char **            g_app_launch_context_get_environment       (GAppLaunchContext *context);

char *             g_app_launch_context_get_display           (GAppLaunchContext *context,
                                                               GAppInfo          *info,
                                                               GList             *files);
char *             g_app_launch_context_get_startup_notify_id (GAppLaunchContext *context,
                                                               GAppInfo          *info,
                                                               GList             *files);
void               g_app_launch_context_launch_failed         (GAppLaunchContext *context,
                                                               const(char)*        startup_notify_id);




